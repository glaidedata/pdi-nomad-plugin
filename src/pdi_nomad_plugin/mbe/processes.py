import json
import random

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from epic_scraper.epicfileimport.epic_module import (
    filename_2_dataframename as fn2dfn,
)
from nomad.datamodel import EntryArchive
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.hdf5 import HDF5Reference
from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
    ELNComponentEnum,
    H5WebAnnotation,
    SectionProperties,
)
from nomad.datamodel.metainfo.basesections import (
    Component,
    CompositeSystemReference,
    Experiment,
    Process,
    ProcessStep,
    SectionReference,
    System,
    SystemComponent,
)
from nomad.datamodel.metainfo.plot import (
    PlotlyFigure,
    PlotSection,
)
from nomad.datamodel.metainfo.workflow import (
    Link,
)
from nomad.metainfo import (
    Datetime,
    Quantity,
    Reference,
    SchemaPackage,
    Section,
    SubSection,
)
from nomad.units import ureg
from nomad_material_processing.general import (
    SubstrateReference,
    ThinFilmReference,
    TimeSeries,
)
from nomad_material_processing.vapor_deposition.cvd.general import (
    Rotation,
)
from nomad_material_processing.vapor_deposition.general import (
    ChamberEnvironment,
    Pressure,
    SubstrateHeater,
    Temperature,
    VaporDeposition,
    VaporDepositionStep,
)
from nomad_material_processing.vapor_deposition.pvd.general import (
    PVDSampleParameters,
)
from nomad_measurements.general import ActivityReference
from nomad_measurements.xrd.schema import ELNXRayDiffraction

from pdi_nomad_plugin.characterization.schema import (
    AFMmeasurement,
    LaserReflectance,
    LightMicroscope,
    MassSpectrometry,
    Pyrometry,
    RHEEDMeasurement,
)
from pdi_nomad_plugin.general.schema import (
    PDIMBECategory,
    SampleCutPDI,
)
from pdi_nomad_plugin.mbe.instrument import (
    FilledSubstrateHolderPDIReference,
    Shutter,
    SourcePDI,
)
from pdi_nomad_plugin.mbe.materials import ThinFilmMbe, ThinFilmStackMbePDI
from pdi_nomad_plugin.utils import (
    add_impinging_flux_to_hdf5,
    add_units_to_hdf5,
    calculate_impinging_flux,
    create_archive,
    create_hdf5_file,
    link_growth_process,
    read_fitting,
    read_shutters,
    set_sample_status,
    xlsx_to_dict,
)

m_package = SchemaPackage()


timezone = 'Europe/Berlin'


def random_rgb():
    return (
        f'{random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)}'
    )


def hdf5_2_datetime(archive, hdf5_dataset_path):
    timestamp_string_array = HDF5Reference.read_dataset(archive, hdf5_dataset_path)
    timestamp_string_list = [ts.decode('utf-8') for ts in timestamp_string_array]
    return pd.to_datetime(
        timestamp_string_list, format='ISO8601'
    )  # 2024-11-21 00:19:37.291000+01:00


class SystemComponentPDI(SystemComponent):
    """
    A section for describing a system component and its role in a composite system.
    """

    molar_concentration = Quantity(
        type=np.float64,
        description='The solvent for the current substance.',
        unit='mol/liter',
        a_eln=dict(component='NumberEditQuantity', defaultDisplayUnit='mol/liter'),
        a_tabular={
            'name': 'Precursors/Molar conc',
            # "unit": "gram"
        },
    )
    system = Quantity(
        type=Reference(System.m_def),
        description='A reference to the component system.',
        a_eln=dict(component='ReferenceEditQuantity'),
    )


class PrecursorsPreparationPDI(Process, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'hide': [
                'instruments',
                'steps',
                'samples',
            ]
        },
        label_quantity='name',
        categories=[PDIMBECategory],
        label='PrecursorsPreparation',
    )
    data_file = Quantity(
        type=str,
        description='Upload here the spreadsheet file containing the deposition control data',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    lab_id = Quantity(
        type=str,
        description='FILL',
        a_tabular={'name': 'Precursors/Sample ID'},
        a_eln={'component': 'StringEditQuantity', 'label': 'Sample ID'},
    )
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    name = Quantity(
        type=str,
        description='FILL',
        a_tabular={'name': 'Precursors/number'},
        a_eln={
            'component': 'StringEditQuantity',
        },
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    flow_titanium = Quantity(  # TODO make this a single flow
        type=np.float64,
        description='FILL THE DESCRIPTION',
        a_tabular={'name': 'Precursors/Set flow Ti'},
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'ml / minute'},
        unit='ml / minute',
    )
    flow_calcium = Quantity(
        type=np.float64,
        description='FILL THE DESCRIPTION',
        a_tabular={'name': 'Precursors/Set flow Ca'},
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'ml / minute'},
        unit='ml / minute',
    )
    # precursors = SubSection(
    #     section_def=SystemComponent,
    #     description="""
    #     A precursor used in MBE. It can be a solution, a gas, or a solid.
    #     """,
    #     repeats=True,
    # )
    components = SubSection(
        description="""
        A list of all the components of the composite system containing a name, reference
        to the system section and mass of that component.
        """,
        section_def=Component,
        repeats=True,
    )


class PrecursorsPreparationPDIReference(ActivityReference):
    """
    A section used for referencing a PrecursorsPreparationPDI.
    """

    m_def = Section(
        label='PrecursorsPreparationReference',
    )
    reference = Quantity(
        type=PrecursorsPreparationPDI,
        description='A reference to a NOMAD `PrecursorsPreparationPDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='PrecursorsPreparationPDI Reference',
        ),
    )


class PyrometryReference(SectionReference):
    """
    A section used for referencing a pyrometry.
    """

    reference = Quantity(
        type=Pyrometry,
        description='A reference to a NOMAD `Pyrometry` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Pyrometry Reference',
        ),
    )


class LaserReflectanceReference(SectionReference):
    """
    A section used for referencing a LaserReflectance.
    """

    reference = Quantity(
        type=LaserReflectance,
        description='A reference to a NOMAD `LaserReflectance` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Laser Reflectance Reference',
        ),
    )


class HallMeasurementReference(SectionReference):
    """
    A section used for referencing a HallMeasurement.
    The class is taken from the dedicated Lakeshore plugin
    """

    reference = Quantity(
        type=ArchiveSection,
        description='A reference to a NOMAD `HallMeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Hall Measurement Reference',
        ),
    )


class AFMmeasurementReference(SectionReference):
    """
    A section used for referencing a AFMmeasurement.
    """

    reference = Quantity(
        type=AFMmeasurement,
        description='A reference to a NOMAD `AFMmeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='AFM Measurement Reference',
        ),
    )


class MassSpectrometryReference(SectionReference):
    """
    A section used for referencing a MassSpectrometry.
    """

    reference = Quantity(
        type=MassSpectrometry,
        description='A reference to a NOMAD `MassSpectrometry` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='MassSpectrometry Measurement Reference',
        ),
    )


class RHEEDReference(SectionReference):
    """
    RHEED measurement reference
    """

    reference = Quantity(
        type=RHEEDMeasurement,
        description='A reference to a NOMAD `RHEEDMeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='RHEEDMeasurement Measurement Reference',
        ),
    )


class LiMimeasurementReference(SectionReference):
    """
    A section used for referencing a LightMicroscope.
    """

    reference = Quantity(
        type=LightMicroscope,
        description='A reference to a NOMAD `LightMicroscope` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Light Microscope Measurement Reference',
        ),
    )


class XRDmeasurementReference(SectionReference):
    """
    A section used for referencing a LightMicroscope.
    """

    sample_id = Quantity(
        type=str,
        description='The sample to be linked within the XRD measurement',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    reference = Quantity(
        type=ELNXRayDiffraction,
        description='A reference to a NOMAD `ELNXRayDiffraction` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='XRD Measurement Reference',
        ),
    )
    phase = Quantity(
        type=str,
        description='Phase type obtained from HRXRD',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    peak_position_2theta = Quantity(
        type=np.float64,
        description='Peak Position - 2theta',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_fwhm_2theta = Quantity(
        type=np.float64,
        description='Peak Position - 2theta',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_position_omega = Quantity(
        type=np.float64,
        description='Peak Position - Omega',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_fwhm_rocking_curve = Quantity(
        type=str,
        description='Peak FWHM Rocking Curve',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    reflection = Quantity(
        type=str,
        description='Peak FWHM Rocking Curve',
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        description='Notes and comments.',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.RichTextEditQuantity,
        ),
    )

    def normalize(self, archive, logger):
        super().normalize(archive, logger)
        if (
            hasattr(self, 'reference')
            and self.reference is not None
            and hasattr(self, 'sample_id')
        ):
            # xrd_context = ServerContext(
            #     get_upload_with_read_access(
            #         archive.m_context.upload_id,
            #         User(
            #             is_admin=True,
            #             user_id=archive.metadata.main_author.user_id,
            #         ),
            #         include_others=True,
            #     )
            # )

            with archive.m_context.raw_file(
                self.reference.m_parent.metadata.mainfile, 'r'
            ) as xrd_file:
                updated_xrd_file = json.load(xrd_file)
                updated_xrd_file['data']['samples'] = [
                    CompositeSystemReference(
                        lab_id=self.sample_id,
                    ).m_to_dict()
                ]

            create_archive(
                updated_xrd_file,
                archive.m_context,
                self.reference.m_parent.metadata.mainfile,
                'json',
                logger,
                overwrite=True,
            )


class InSituCharacterizationMbePDI(ArchiveSection):
    m_def = Section(
        a_h5web=H5WebAnnotation(
            paths=[
                'pyrometry/*/pyrometer_temperature',
                'laser_reflectance/*/laser_reflectance_intensity',
            ]
        ),
    )
    pyrometry = SubSection(
        section_def=Pyrometry,
        repeats=True,
    )
    laser_reflectance = SubSection(
        section_def=LaserReflectanceReference,
        repeats=True,
    )
    mass_spectrometry = SubSection(
        section_def=MassSpectrometryReference,
        repeats=True,
    )
    rheed = SubSection(
        section_def=RHEEDReference,
        repeats=True,
    )


class CharacterizationMbePDI(ArchiveSection):
    """
    A wrapped class to gather all the characterization methods in MBE
    """

    xrd = SubSection(
        section_def=XRDmeasurementReference,
        repeats=True,
    )
    hall = SubSection(
        section_def=HallMeasurementReference,
        repeats=True,
    )
    afm = SubSection(
        section_def=AFMmeasurementReference,
        repeats=True,
    )
    light_microscopy = SubSection(
        section_def=LiMimeasurementReference,
        repeats=True,
    )


class ShaftTemperature(Temperature):
    """
    Central shaft temperature (to hold the susceptor)
    """

    pass


class FilamentTemperature(Temperature):
    """
    heating filament temperature
    """

    pass


class LayTecTemperature(Temperature):
    """
    Central shaft temperature (to hold the susceptor)
    """

    pass


class PressurePDI(Pressure):
    """
    The pressure during the deposition process.
    """

    m_def = Section(a_h5web=H5WebAnnotation(axes='time', signal='value'))
    value = Quantity(
        type=HDF5Reference,
        shape=[],
    )
    time = Quantity(
        type=HDF5Reference,
        shape=[],
    )


class ChamberEnvironmentMbe(ChamberEnvironment):
    pressure = SubSection(
        section_def=PressurePDI,
        label='Pressure_1',
    )
    pressure_2 = SubSection(
        section_def=PressurePDI,
        label='Pressure_2',
    )
    bep = SubSection(
        section_def=PressurePDI,
        label='Beam Equivalent Pressure',
    )
    rotation = SubSection(
        section_def=Rotation,
    )
    heater = SubSection(
        section_def=SubstrateHeater,
    )


class SubstrateHeaterPower(TimeSeries):
    """
    The working output power measured from the substrate termocouple (dimensionless).
    """

    m_def = Section(a_h5web=H5WebAnnotation(axes='time', signal='value'))
    value = Quantity(
        type=HDF5Reference,
        unit='dimensionless',
        shape=[],
        a_h5web=H5WebAnnotation(
            long_name='power',
        ),
    )
    time = Quantity(
        type=HDF5Reference,
        description='The process time when each of the values were recorded.',
        shape=[],
    )


class SubstrateHeaterTemperature(TimeSeries):  # , PlotSection):
    """
    The temperature of the heater during the deposition process.
    """

    # m_def = Section(
    # a_h5web=H5WebAnnotation(
    #     axes=['pyro_time'], signal='pyro_value', auxiliary_signals=['value']
    # ),
    # a_eln={
    #     'hide': [
    #         'pyro_value',
    #         'pyro_time',
    #     ]
    # },
    # )

    value = Quantity(
        type=HDF5Reference,
        shape=[],
    )
    time = Quantity(
        type=HDF5Reference,
        description='The process time when each of the values were recorded.',
        shape=[],
    )

    # pyro_value = Quantity(
    #     type=HDF5Reference,
    #     shape=[],
    # )
    # pyro_time = Quantity(
    #     type=HDF5Reference,
    #     shape=[],
    # )

    # def normalize(self, archive, logger):
    #     super().normalize(archive, logger)
    #     #   plotly figure -----> HDF5Dataset solution:
    #     # ###
    #     with self.time as deserialized:
    #         time_array = deserialized[:]
    #     with self.value as deserialized:
    #         value_array = deserialized[:]
    #     with (
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.value as deserialized
    #     ):
    #         pyrometer_temperature = deserialized[:]
    #     with (
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.time as deserialized
    #     ):
    #         pyrometer_time = deserialized[:]

    #     # plotly figure -----> HDF5Reference solution:
    #     # ###
    #     time_array = HDF5Reference.read_dataset(archive, self.time)
    #     value_array = HDF5Reference.read_dataset(archive, self.value)
    #     pyrometer_time = HDF5Reference.read_dataset(
    #         archive,
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.time,
    #     )
    #     pyrometer_temperature = HDF5Reference.read_dataset(
    #         archive,
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.value,
    #     )

    #     # plotly figure
    #     # ###
    #     fig = go.Figure()
    #     fig.add_trace(
    #         go.Scatter(
    #             x=time_array,
    #             y=value_array,
    #             name='Sub Temp',
    #             line=dict(color='#2A4CDF', width=4),
    #             yaxis='y',
    #         ),
    #     )
    #     fig.add_trace(
    #         go.Scatter(
    #             x=pyrometer_time,
    #             y=pyrometer_temperature,
    #             name='Pyro Temp',
    #             line=dict(color='#90002C', width=2),
    #             yaxis='y',
    #         ),
    #     )
    #     fig.update_layout(
    #         template='plotly_white',
    #         dragmode='zoom',
    #         xaxis=dict(
    #             fixedrange=False,
    #             autorange=True,
    #             title='Process time / s',
    #             mirror='all',
    #             showline=True,
    #             gridcolor='#EAEDFC',
    #         ),
    #         yaxis=dict(
    #             fixedrange=False,
    #             title='Temperature / °C',
    #             tickfont=dict(color='#2A4CDF'),
    #             gridcolor='#EAEDFC',
    #         ),
    #         showlegend=True,
    #     )
    #     self.figures = [PlotlyFigure(label='figure 1', figure=fig.to_plotly_json())]

    #             fixedrange=False,
    #             title='Temperature / °C',
    #             tickfont=dict(color='#2A4CDF'),
    #             gridcolor='#EAEDFC',
    #         ),
    #         showlegend=True,
    #     )
    #     self.figures = [PlotlyFigure(label='figure 1', figure=fig.to_plotly_json())]


class SubstrateHeaterCurrent(TimeSeries):
    """
    The current of the heater during the deposition process.
    """

    m_def = Section(
        a_plot=[
            {
                'label': 'measured current',
                'x': 'time',
                'y': ['value'],
            },
        ],
        a_eln={
            'hide': [
                'set_value',
                'set_time',
            ]
        },
    )
    value = Quantity(
        type=float,
        unit='ampere',
        shape=['*'],
    )
    time = Quantity(
        type=Datetime,
        description='The process time when each of the values were recorded.',
        shape=['*'],
    )


class SubstrateHeaterVoltage(TimeSeries):
    """
    The voltage of the heater during the deposition process.
    """

    m_def = Section(
        a_plot=[
            {
                'label': 'measured voltage',
                'x': 'time',
                'y': ['value'],
            },
        ],
        a_eln={
            'hide': [
                'set_value',
                'set_time',
            ]
        },
    )
    value = Quantity(
        type=float,
        unit='volt',
        shape=['*'],
    )
    time = Quantity(
        type=Datetime,
        description='The process time when each of the values were recorded.',
        shape=['*'],
    )


class SampleParametersMbe(PVDSampleParameters):
    m_def = Section(
        a_h5web=H5WebAnnotation(paths=['substrate_temperature']),
    )
    name = Quantity(
        type=str,
        description="""
        Sample name.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    distance_to_source = Quantity(
        type=float,
        unit='meter',
        description="""
        The distance between the substrate and all the sources.
        In the case of multiple sources, the distances are listed in the same order
        as the sources are listed in the parent `VaporDepositionStep` section.
        """,
        shape=['*'],
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'millimeter'},
    )
    substrate_temperature = SubSection(
        section_def=SubstrateHeaterTemperature,
    )
    substrate_power = SubSection(
        section_def=SubstrateHeaterPower,
    )
    substrate_voltage = SubSection(
        section_def=SubstrateHeaterVoltage,
    )
    substrate_current = SubSection(
        section_def=SubstrateHeaterCurrent,
    )


class GrowthStepMbePDI(VaporDepositionStep, PlotSection):
    """
    Growth step for MBE PDI
    """

    m_def = Section(
        # label='Growth Step Mbe 2',
        a_eln=None,
    )

    name = Quantity(
        type=str,
        description="""
        A short and descriptive name for this step.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
            label='Step name',
        ),
    )
    step_index = Quantity(
        type=str,
        description='the ID from RTG',
        a_eln={
            'component': 'StringEditQuantity',
        },
    )
    # duration = VaporDepositionStep.duration.m_copy()

    duration = Quantity(
        type=float,
        unit='second',
        a_eln=ELNAnnotation(
            component='NumberEditQuantity',
        ),
    )

    comment = Quantity(
        type=str,
        description='description',
        a_eln={'component': 'StringEditQuantity'},
        label='Notes',
    )
    sample_parameters = SubSection(
        section_def=SampleParametersMbe,
        repeats=True,
    )
    sources = SubSection(
        section_def=SourcePDI,
        repeats=True,
    )
    environment = SubSection(
        section_def=ChamberEnvironmentMbe,
    )

    in_situ_characterization = SubSection(section_def=InSituCharacterizationMbePDI)


class GrowthStepMbeManualMetadataPDI(ProcessStep):
    """
    Some manually filled in metadata for the growth process.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'name',
                    'datetime',
                    'end_time',
                    'duration',
                ]
            ),
        ),
    )
    end_time = Quantity(
        type=Datetime,
        description='The date and time when this process was finished.',
        a_eln=dict(component='DateTimeEditQuantity', label='ending time'),
    )
    target_material = Quantity(
        type=str,
        shape=['*'],
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )


class GrowthMbeManualMetadataPDI(Process):
    """
    Some manually filled in metadata for the growth process.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            hide=[
                'name',
                'method',
                'datetime',
                'end_time',
                'lab_id',
                'location',
                'description',
                'samples',
                'instruments',
            ]
        )
    )
    steps = SubSection(
        section_def=GrowthStepMbeManualMetadataPDI,
        description="""
        An ordered list of all the steps that make up the growth run process.
        """,
        repeats=True,
    )


class GrowthMbePDI(VaporDeposition, PlotSection, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'method',
                    'name',
                    'lab_id',
                    'data_file',
                    'hdf5_file',
                    'start_time',
                    'end_time',
                    'datetime',
                    'recalculate_growth_start_time',
                    'duration',
                    'tags',
                    'description',
                ],
            ),
            hide=[
                'location',
            ],
        ),
        label_quantity='lab_id',
        categories=[PDIMBECategory],
        label='Growth Process',
        # a_h5web=H5WebAnnotation(
        #     paths=[
        #         'steps/0/sources/*/impinging_flux/*',
        #     ]
        # ),
    )
    name = Quantity(
        type=str,
        description="""
        A short and descriptive name for this growth process.
        """,
    )
    method = Quantity(
        type=str,
        default='MBE PDI',
    )
    start_time = Quantity(
        type=Datetime,
        description='The date and time when the sample was loaded from growth chamber.',
        a_eln=dict(  # component='DateTimeEditQuantity',
            label='substrate load time'
        ),
    )
    end_time = Quantity(
        type=Datetime,
        description='The date and time when the sample was unloaded from growth chamber.',
        a_eln=dict(  # component='DateTimeEditQuantity',
            label='substrate unload time'
        ),
    )
    # datetime = Quantity(
    #     type=Datetime,
    #     description='The date and time when the growth was started.',
    #     a_eln=dict(component='DateTimeEditQuantity', label='growth start time'),
    # )
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    data_file = Quantity(
        type=str,
        description='Spreadsheet file containing the deposition control data',
        a_browser={'adaptor': 'RawFileAdaptor'},
        # a_eln={'component': 'FileEditQuantity'},
    )
    hdf5_file = Quantity(
        type=str,
        description='The HDF5 file containing the data for this growth process.',
        a_browser={'adaptor': 'RawFileAdaptor'},
        # a_eln={'component': 'FileEditQuantity'},
    )
    description = Quantity(
        type=str,
        description='description',
        a_eln={'component': 'StringEditQuantity'},
        label='notes',
    )
    lab_id = Quantity(
        type=str,
        description="""
        The ID found in Messages.txt raw file.
        It is composed by the Growth Run ID and the Sample Holder ID.
        """,
        a_eln=dict(  # component='StringEditQuantity',
            label='growth process ID'
        ),
    )
    steps = SubSection(
        section_def=GrowthStepMbePDI,
        repeats=True,
    )
    shutters = SubSection(
        section_def=Shutter,
        repeats=True,
    )
    samples = SubSection(
        section_def=CompositeSystemReference,
        repeats=True,
    )

    def normalize(self, archive, logger):
        # plotly figure list
        self.figures = []

        # plotly gas flows figure:
        fig = go.Figure()
        # Define custom tick values and labels
        tickvals_y = []
        ticktext_y = []
        for sources_index, source in enumerate(self.steps[0].sources):
            if len(source.impinging_flux) > 0:
                current_rgb = random_rgb()
                rgb_10 = f'rgba({current_rgb}, 1)'
                if source.impinging_flux[0].value is not None:
                    if source.impinging_flux[0].time is not None:
                        timestamp_array = hdf5_2_datetime(
                            archive,
                            f'{source.impinging_flux[0].time.rsplit("/", 1)[0]}/timestamp',
                        )  # fetch the hdf5 dataset from the already used path for time
                        value_array = HDF5Reference.read_dataset(
                            archive,
                            source.impinging_flux[0].value,
                        )
                        # Add baseline for each shutter
                        fig.add_trace(
                            go.Scatter(
                                x=timestamp_array,
                                y=[1 * sources_index for _ in value_array],
                                mode='lines',
                                name=f'{source.epic_loop}'
                                if source.epic_loop is not None
                                else 'No name',
                                line=dict(color=rgb_10, width=2),
                                showlegend=False,
                            ),
                        )
                        max_y = np.max(value_array)
                        fig.add_trace(
                            go.Scatter(
                                x=timestamp_array,
                                y=[
                                    value / max_y + 1 * sources_index
                                    for value in value_array
                                ],
                                mode='markers+lines',
                                name=f'{source.epic_loop}'
                                if source.epic_loop is not None
                                else 'No name',
                                line=dict(color=rgb_10, width=2),
                                line_shape='hv',
                                fill='tonexty',
                            ),
                        )

                        # Define custom tick values and labels
                        tickvals_y.append(1 * sources_index + 1)
                        ticktext_y.append(f'{max_y:.2e}')

                        fig.update_layout(
                            template='plotly_white',
                            dragmode='zoom',
                            xaxis=dict(
                                fixedrange=False,
                                autorange=True,
                                title='Timestamp',
                                mirror='all',
                                showline=True,
                                gridcolor='#EAEDFC',
                            ),
                            yaxis=dict(
                                fixedrange=False,
                                title='Gas flows',
                                tickfont=dict(color='#2A4CDF'),
                                gridcolor='#EAEDFC',
                                tickvals=tickvals_y,
                                ticktext=ticktext_y,
                            ),
                            showlegend=True,
                        )
        self.figures.append(
            PlotlyFigure(
                label='Gas flows ',
                figure=fig.to_plotly_json(),
            )
        )

        # plotly temperature figure with HDF5Reference arrays:
        sub_time = self.steps[0].sample_parameters[0].substrate_temperature.time
        sub_value = self.steps[0].sample_parameters[0].substrate_temperature.value
        pyro_time = (
            self.steps[0]
            .in_situ_characterization.pyrometry[0]
            .pyrometer_temperature.time
        )
        pyro_value = (
            self.steps[0]
            .in_situ_characterization.pyrometry[0]
            .pyrometer_temperature.value
        )
        if (
            sub_time is not None
            and sub_value is not None
            and pyro_time is not None
            and pyro_value is not None
        ):
            timestamp_array = hdf5_2_datetime(
                archive, f'{sub_time.rsplit("/", 1)[0]}/timestamp'
            )  # fetch the hdf5 dataset from the already used path for time
            value_array = HDF5Reference.read_dataset(archive, sub_value)

            pyrometer_timestamp = hdf5_2_datetime(
                archive, f'{pyro_time.rsplit("/", 1)[0]}/timestamp'
            )  # fetch the hdf5 dataset from the already used path for time
            pyrometer_temperature = HDF5Reference.read_dataset(archive, pyro_value)

            # plotly temperature figure
            fig = go.Figure()
            fig.add_trace(
                go.Scatter(
                    x=timestamp_array,
                    y=value_array,
                    name='Sub Temp',
                    line=dict(color='#2A4CDF', width=4),
                    yaxis='y',
                ),
            )
            fig.add_trace(
                go.Scatter(
                    x=pyrometer_timestamp,
                    y=pyrometer_temperature,
                    name='Pyro Temp',
                    line=dict(color='#90002C', width=2),
                    yaxis='y',
                ),
            )
            fig.update_layout(
                template='plotly_white',
                dragmode='zoom',
                xaxis=dict(
                    fixedrange=False,
                    autorange=True,
                    title='Timestamp',
                    mirror='all',
                    showline=True,
                    gridcolor='#EAEDFC',
                ),
                yaxis=dict(
                    fixedrange=False,
                    title='Temperature / °C',
                    tickfont=dict(color='#2A4CDF'),
                    gridcolor='#EAEDFC',
                ),
                showlegend=True,
            )
            self.figures.append(
                PlotlyFigure(label='Temperature', figure=fig.to_plotly_json())
            )

        # plotly shutters figure:
        if self.shutters is not None:
            fig = go.Figure()
            for index, shutter in enumerate(self.shutters):
                current_rgb = random_rgb()
                rgb_10 = f'rgba({current_rgb}, 1)'
                # rgb_07 = f'rgba({current_rgb}, 0.7)'
                if shutter.shutter_status is not None:
                    if (
                        shutter.shutter_status.timestamp is not None
                        and shutter.shutter_status.value is not None
                    ):
                        # Add lines at each point
                        # for j in shutter.shutter_status.timestamp:
                        #     fig.add_shape(
                        #         type='line',
                        #         x0=j,
                        #         y0=0,
                        #         x1=j,
                        #         y1=1 + 1 * index,
                        #         line=dict(color='rgba(0,0,0, 1)', width=1),
                        #     )
                        # Add baseline for each shutter
                        fig.add_trace(
                            go.Scatter(
                                x=shutter.shutter_status.timestamp,
                                y=[1 * index for _ in shutter.shutter_status.value],
                                mode='lines',
                                name=shutter.name,
                                line=dict(color=rgb_10, width=2),
                                showlegend=False,
                            ),
                        )
                        fig.add_trace(
                            go.Scatter(
                                x=shutter.shutter_status.timestamp,
                                y=[
                                    value + 1 * index
                                    for value in shutter.shutter_status.value
                                ],
                                mode='markers+lines',
                                name=shutter.name,
                                line=dict(color=rgb_10, width=2),
                                line_shape='hv',
                                fill='tonexty',
                            ),
                        )
                        # # Add rectangles between each pair of points
                        # for i in range(len(shutter.shutter_status.timestamp) - 1):
                        #     if shutter.shutter_status.value[i] == 0:
                        #         continue
                        #     if shutter.shutter_status.value[i] == 1:
                        #         fig.add_shape(
                        #             type='rect',
                        #             x0=shutter.shutter_status.timestamp[i],
                        #             y0=1 + 1 * index,
                        #             x1=shutter.shutter_status.timestamp[i + 1],
                        #             y1=0 + 1 * index,
                        #             fillcolor=rgb_07,
                        #             line=dict(color=rgb_10, width=2),
                        #             layer='above',
                        #         )
                        #         continue

            # Define custom tick values and labels
            # tickvals = self.shutters[0].shutter_status.timestamp
            # ticktext = [shutter.shutter_status.timestamp]

            fig.update_shapes(dict(xref='x', yref='y'))
            fig.update_layout(
                template='plotly_white',
                dragmode='zoom',
                xaxis=dict(
                    fixedrange=False,
                    autorange=True,
                    title='Timestamp',
                    mirror='all',
                    showline=True,
                    gridcolor='#EAEDFC',
                    # tickvals=tickvals,  # Set custom tick values
                    # ticktext=ticktext,  # Set custom tick labels
                ),
                yaxis=dict(
                    fixedrange=False,
                    title='Shutter status',
                    tickfont=dict(color='#2A4CDF'),
                    gridcolor='#EAEDFC',
                ),
                showlegend=True,
                legend=dict(
                    itemsizing='constant',  # Ensures the size of the legend items is constant
                    itemwidth=40,  # Adjust the width of the legend items
                ),
                legend_traceorder='reversed',
            )

            self.figures.append(
                PlotlyFigure(label='Shutters', figure=fig.to_plotly_json())
            )

        # workflow normalization
        archive.workflow2 = None
        super().normalize(archive, logger)
        if self.steps is not None:
            inputs = []
            outputs = []
            for step in self.steps:
                if step.sample_parameters is not None:
                    for sample in step.sample_parameters:
                        if sample.layer is not None:
                            outputs.append(
                                Link(
                                    name=f'{sample.layer.name}',
                                    section=sample.layer.reference,
                                )
                            )
                        if sample.substrate is not None:
                            outputs.append(
                                Link(
                                    name=f'{sample.substrate.name}',
                                    section=sample.substrate.reference,
                                )
                            )
                        if (
                            sample.substrate is not None
                            and sample.substrate.reference is not None
                        ):
                            if hasattr(
                                getattr(sample.substrate.reference, 'substrate'),
                                'name',
                            ):
                                # sample.substrate.reference.substrate.reference is not None:
                                inputs.append(
                                    Link(
                                        name=f'{sample.substrate.reference.substrate.name}',
                                        section=getattr(
                                            sample.substrate.reference.substrate,
                                            'reference',
                                            None,
                                        ),
                                    )
                                )
            archive.workflow2.outputs.extend(set(outputs))
            archive.workflow2.inputs.extend(set(inputs))


class SampleCutPDIReference(ActivityReference):
    """
    A section used for referencing a SampleCutPDI.
    """

    m_def = Section(
        label='SampleCutReference',
    )
    reference = Quantity(
        type=SampleCutPDI,
        description='A reference to a NOMAD `SampleCutPDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
        ),
    )


class GrowthMbePDIReference(ActivityReference):
    """
    A section used for referencing a GrowthMbePDI.
    """

    m_def = Section(
        label='GrowthProcessReference',
    )
    reference = Quantity(
        type=GrowthMbePDI,
        description='A reference to a NOMAD `GrowthMbePDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
        ),
    )
    lab_id = Quantity(
        type=str,
        description="""
        The readable identifier for the activity.
        """,
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
            label='Growth process ID',
        ),
    )


class ExperimentMbePDI(Experiment, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        # a_eln={"hide": ["steps"]},
        categories=[PDIMBECategory],
        label='Experiment MBE',
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'name',
                    'lab_id',
                    'start_time',
                    'end_time',
                    'datetime',
                    'recalculate_growth_start_time',
                    'data_file',
                    'hdf5_file',
                    'tags',
                    'description',
                ]
            ),
            # hide=[
            #     'datetime',
            # ],
        ),
    )

    method = Quantity(
        type=str,
    )
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    start_time = Quantity(
        type=Datetime,
        description='The date and time when the sample was loaded from growth chamber.',
        a_eln=dict(  # component='DateTimeEditQuantity',
            label='substrate load time'
        ),
    )
    end_time = Quantity(
        type=Datetime,
        description='The date and time when the sample was unloaded from growth chamber.',
        a_eln=dict(  # component='DateTimeEditQuantity',
            label='substrate unload time'
        ),
    )
    datetime = Quantity(
        type=Datetime,
        description='The date and time when the growth was started.',
        a_eln=dict(component='DateTimeEditQuantity', label='growth start time'),
    )
    recalculate_growth_start_time = Quantity(
        type=bool,
        description='If true, the growth start time will be recalculated based on the date found in growth start time field.',
        a_eln=dict(component='BoolEditQuantity', label='recalculate growth start time'),
    )
    data_file = Quantity(
        type=str,
        description='Spreadsheet file containing the deposition control data',
        a_browser={'adaptor': 'RawFileAdaptor'},
        # a_eln={'component': 'FileEditQuantity'},
    )
    hdf5_file = Quantity(
        type=str,
        description='The HDF5 file containing the data for this growth process.',
        a_browser={'adaptor': 'RawFileAdaptor'},
        # a_eln={'component': 'FileEditQuantity'},
    )
    lab_id = Quantity(
        type=str,
        description="""
        ID of the growth run to be referenced in this experiment.
        It can be found in the Messages.txt raw file.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
            label='growth process ID',
        ),
    )
    growth_run_logfiles = SubSection(
        section_def=GrowthMbePDIReference,
    )
    growth_run_steps = SubSection(
        section_def=GrowthMbeManualMetadataPDI,
    )
    substrate_holder = SubSection(
        section_def=FilledSubstrateHolderPDIReference,
    )
    samples = SubSection(
        section_def=CompositeSystemReference,
        repeats=True,
    )
    characterization = SubSection(section_def=CharacterizationMbePDI)

    steps = SubSection(
        section_def=ActivityReference,
        repeats=True,
    )

    def normalize(self, archive, logger):
        # archive_sections = (
        #     attr
        #     for attr in vars(self).values()
        #     if isinstance(attr, ArchiveSection) and not isinstance(attr, EntryArchive)
        #     # not isinstance(attr, EntryArchive) avoid including Experiment itself
        # )
        # step_list = []
        # for section in archive_sections:
        #     try:
        #         if section is not None:
        #             step_list.extend(handle_section(section))
        #     except (AttributeError, TypeError, NameError) as e:
        #         print(f'An error occurred in section XXX {section}: {e}')
        # self.steps = [step for step in step_list if step is not None]

        # activity_lists = (
        #     attr for attr in vars(self).values() if isinstance(attr, list)
        # )
        # for activity_list in activity_lists:
        #     for activity in activity_list:
        #         if isinstance(activity, ArchiveSection):
        #             try:
        #                 step_list.extend(handle_section(activity))
        #             except (AttributeError, TypeError, NameError) as e:
        #                 print(f'An error occurred in section YYY {section}: {e}')
        # self.steps = [step for step in step_list if step is not None]

        # archive.workflow2 = None
        super().normalize(archive, logger)


        # Load lab_id from subfolder if not set        
        if self.lab_id is None:
            parts = archive.metadata.mainfile.split('/',1)
            if len(parts) > 1:
                self.lab_id = parts[0]
            

        # fill lab_id if exp is linked to growth archive
        if self.growth_run_logfiles is not None:
            if self.growth_run_logfiles.reference:
                growth_id = self.growth_run_logfiles.reference.lab_id
                growth_ref = link_growth_process(archive, growth_id, logger)
                if growth_id is not None:
                    self.lab_id = growth_id
                if growth_ref is not None:
                    self.growth_run_logfiles = GrowthMbePDIReference(
                        reference=growth_ref
                    )
                    self.growth_run_logfiles.normalize(archive, logger)


        # link to growth archive if lab_id is filled in exp
        if self.lab_id is not None and self.growth_run_logfiles is None:
            growth_ref = link_growth_process(archive, self.lab_id, logger)
            if growth_ref is not None:
                self.growth_run_logfiles = GrowthMbePDIReference(reference=growth_ref)
                self.growth_run_logfiles.normalize(archive, logger)

        # fill metadata from growth run to experiment
        if self.growth_run_logfiles is not None:
            if self.growth_run_logfiles.reference:
                data_file = self.growth_run_logfiles.reference.data_file
                hdf5_file = self.growth_run_logfiles.reference.hdf5_file
                load_time = self.growth_run_logfiles.reference.start_time
                unload_time = self.growth_run_logfiles.reference.end_time
                datetime = self.growth_run_logfiles.reference.datetime
                if data_file is not None:
                    self.data_file = data_file
                if hdf5_file is not None:
                    self.hdf5_file = hdf5_file
                if load_time is not None:
                    self.start_time = load_time
                if unload_time is not None:
                    self.end_time = unload_time
                if (
                    datetime is not None
                    and self.recalculate_growth_start_time is not True
                ):
                    self.datetime = datetime
                if self.recalculate_growth_start_time is None:
                    self.recalculate_growth_start_time = False

        # make sample holder available on overview page of upload
        if self.substrate_holder is None:
            self.substrate_holder = FilledSubstrateHolderPDIReference()
        # setting the sample status
        if self.substrate_holder:
            if self.substrate_holder.reference:
                for sample_holder_position in self.substrate_holder.reference.positions:
                    if sample_holder_position.substrate:
                        set_sample_status(
                            sample_holder_position.substrate.reference,
                            logger,
                            as_delivered=False,
                            fresh=False,
                            processed=sample_holder_position.substrate.reference.grown
                            if sample_holder_position.substrate.reference.grown
                            else False,
                            grown=True,
                        )

        # Create or update samples archives
        # This section handles two cases:
        # 1. Create thin film stacks when only a substrate holder is present
        # 2. Update existing thin film stacks when a growth process is linked
        
        # First, get the growth process ID if available
        growth_id = None
        if self.growth_run_logfiles is not None and self.growth_run_logfiles.reference:
            growth_id = self.growth_run_logfiles.reference.lab_id
        
        # Case 1: Create new samples if none exist yet and substrate holder is available
        if self.substrate_holder is not None and not self.samples:
            if self.substrate_holder.reference:
                self.samples = []
                for sample_holder_position in self.substrate_holder.reference.positions:
                    if sample_holder_position.substrate:
                        filetype = 'yaml'
                        # Use holder ID if growth_id is not available
                        holder_id = self.substrate_holder.reference.lab_id if hasattr(self.substrate_holder.reference, 'lab_id') else "holder"
                        position_name = sample_holder_position.name
                        stack_id = f'{growth_id}_{position_name}' if growth_id else f'{holder_id}_{position_name}'
                        
                        # Only create layer if growth process is available
                        layer_reference = None
                        if growth_id:
                            layer_id = f'{stack_id}_lyr_1'  # TODO adapt this to the number of layers
                            layer_object = ThinFilmMbe(
                                name=f'{layer_id}',
                                lab_id=layer_id,
                            )
                            layer_archive = EntryArchive(
                                m_context=archive.m_context,
                                data=layer_object,
                            )
                            layer_filename = f'{layer_id}.archive.{filetype}'
                            layer_reference = create_archive(
                                layer_archive.m_to_dict(),
                                archive.m_context,
                                layer_filename,
                                filetype,
                                logger,
                            )
                            
                        # Create sample object
                        sample_object = ThinFilmStackMbePDI(
                            name=stack_id,
                            lab_id=stack_id,
                            datetime=self.datetime if hasattr(self, 'datetime') else None,
                            substrate=SubstrateReference(
                                name=sample_holder_position.substrate.reference.lab_id,
                                reference=sample_holder_position.substrate.reference,
                            ),
                        )
                        
                        # Only add layer if it was created (growth process available)
                        if layer_reference:
                            sample_object.layers.append(
                                ThinFilmReference(
                                    name=layer_id,
                                    reference=layer_reference,
                                )
                            )
                        
                        stack_filename = f'{stack_id}.archive.{filetype}'
                        sample_archive = EntryArchive(
                            m_context=archive.m_context,
                            data=sample_object,
                        )
                        
                        self.samples.append(
                            CompositeSystemReference(
                                reference=create_archive(
                                    sample_archive.m_to_dict(),
                                    archive.m_context,
                                    stack_filename,
                                    filetype,
                                    logger,
                                ),
                            )
                        )
        
        # Case 2: Update existing samples if a growth process has been added and samples already exist
        elif self.substrate_holder is not None and self.samples and growth_id:
            # Create a mapping of position names to existing samples
            MIN_PARTS_IN_LAB_ID = 2  # Minimum number of parts in lab_id (holder_id_position_name)
            position_to_sample = {}
            for sample_ref in self.samples:
                if hasattr(sample_ref, 'reference') and sample_ref.reference:
                    sample = sample_ref.reference
                    if hasattr(sample, 'lab_id') and sample.lab_id:
                        # Extract position name from lab_id (format: holder_id_position_name)
                        parts = sample.lab_id.split('_')
                        if len(parts) >= MIN_PARTS_IN_LAB_ID:
                            position_name = parts[-1]  # Last part should be position name
                            position_to_sample[position_name] = sample
            
            # Now go through substrate holder positions and update corresponding samples
            if self.substrate_holder.reference:
                for sample_holder_position in self.substrate_holder.reference.positions:
                    if sample_holder_position.substrate:
                        position_name = sample_holder_position.name
                        
                        # If we found a matching sample for this position
                        if position_name in position_to_sample:
                            sample = position_to_sample[position_name]
                            
                            # If this sample doesn't have layers yet, add them
                            if not hasattr(sample, 'layers') or not sample.layers:
                                filetype = 'yaml'
                                stack_id = f'{growth_id}_{position_name}'
                                layer_id = f'{stack_id}_lyr_1'  # TODO adapt this to the number of layers
                                
                                # Create layer object
                                layer_object = ThinFilmMbe(
                                    name=f'{layer_id}',
                                    lab_id=layer_id,
                                )
                                layer_archive = EntryArchive(
                                    m_context=archive.m_context,
                                    data=layer_object,
                                )
                                layer_filename = f'{layer_id}.archive.{filetype}'
                                layer_reference = create_archive(
                                    layer_archive.m_to_dict(),
                                    archive.m_context,
                                    layer_filename,
                                    filetype,
                                    logger,
                                )
                                
                                # Update the sample with the new layer and update its ID to include growth ID
                                sample.name = stack_id
                                sample.lab_id = stack_id
                                
                                # Initialize layers list if it doesn't exist
                                if not hasattr(sample, 'layers'):
                                    sample.layers = []
                                
                                # Add the layer
                                sample.layers.append(
                                    ThinFilmReference(
                                        name=layer_id,
                                        reference=layer_reference,
                                    )
                                )
                                
                                # Update the sample archive file
                                with archive.m_context.raw_file(sample.m_parent.metadata.mainfile, 'w') as newfile:
                                    import yaml
                                    yaml.dump(sample.m_parent.m_to_dict(), newfile)
                                
                                logger.info(f"Updated ThinFilmStackMbePDI '{sample.lab_id}' with layer from growth process '{growth_id}'")
                            
                            # If the sample already has layers, don't modify it
                            else:
                                logger.info(f"ThinFilmStackMbePDI '{sample.lab_id}' already has layers, not updating")

        # recalculate the growth start time and rewrite the HDF5 file
        if self.recalculate_growth_start_time:
            self.recalculate_growth_start_time = False
            folder_name = f'/{self.data_file.rsplit("/", 1)[0]}'
            upload_path = archive.m_context.raw_path()
            create_hdf5_file(
                archive, folder_name, upload_path, self.datetime, self.hdf5_file
            )
            mainfile = upload_path + '/' + self.data_file
            (
                config_sheet,
                sources_sheet,
                gasmixing_sheet,
                chamber_sheet,
                pyrometry_sheet,
                lr_sheet,
            ) = xlsx_to_dict(pd.ExcelFile(mainfile))
            # Read Fitting.txt
            fitting = None
            if (
                'flux_calibration' in config_sheet
                and not config_sheet['flux_calibration'].empty
            ):
                file_path = (
                    f'{upload_path}{folder_name}/{config_sheet["flux_calibration"][0]}'
                )
                fitting = read_fitting(file_path, config_sheet)

            # Read Shutters.txt
            shutters = None
            if 'shutters' in config_sheet and not config_sheet['shutters'].empty:
                file_path = f'{upload_path}{folder_name}/{config_sheet["shutters"][0]}'
                shutters = read_shutters(
                    file_path, config_sheet, self.datetime, timezone
                )
            for _, sources_row in sources_sheet.iterrows():
                if (
                    sources_row['EPIC_loop']
                    and fitting is not None
                    and sources_row['source_type'] != 'SUB'
                ):
                    # prepare variables for impinging flux calculation
                    temperature_pint = None
                    time_vector = None
                    for source_object in self.growth_run_logfiles.reference.steps[
                        0
                    ].sources:
                        if source_object.epic_loop != sources_row['EPIC_loop']:
                            continue
                        else:
                            temperature_pint = ureg.Quantity(
                                HDF5Reference.read_dataset(
                                    archive,
                                    source_object.vapor_source.temperature.value,
                                )[:],
                                ureg('°C'),
                            )
                            time_vector = HDF5Reference.read_dataset(
                                archive, source_object.vapor_source.temperature.time
                            )

                    modulated_flux, _, _, _ = calculate_impinging_flux(
                        logger,
                        sources_row,
                        fitting,
                        temperature_pint,
                        time_vector,
                        shutters,
                    )
                    if modulated_flux is not None:
                        add_impinging_flux_to_hdf5(
                            archive,
                            sources_row,
                            modulated_flux,
                            self.hdf5_file,
                            f'{fn2dfn(sources_row["temp_mv"])}/time',
                        )

            add_units_to_hdf5(
                archive,
                logger,
                self.hdf5_file,
                sources_sheet,
                gasmixing_sheet,
                chamber_sheet,
                pyrometry_sheet,
                f'{fn2dfn(sources_row["temp_mv"])}/time',
            )

        # search_result = search(
        #     owner="user",
        #     query={
        #         "results.eln.sections:any": ["GrowthMbe1PDIConstantParameters"],
        #         "upload_id:any": [archive.m_context.upload_id],
        #     },
        #     pagination=MetadataPagination(page_size=10000),
        #     user_id=archive.metadata.main_author.user_id,
        # )
        # # checking if all entries are properly indexed
        # if getattr(
        #     getattr(self, "growth_run_constant_parameters", None), "lab_id", None
        # ) and not getattr(
        #     getattr(self, "growth_run_constant_parameters", None), "reference", None
        # ):
        #     found_id = False
        #     for growth_entry in search_result.data:
        #         if (
        #             self.growth_run_constant_parameters.lab_id
        #             == growth_entry["results"]["eln"]["lab_ids"][0]
        #         ):
        #             found_id = True
        #             self.growth_run_constant_parameters = GrowthMbe1PDIConstantParametersReference(
        #                 reference=f"../uploads/{archive.m_context.upload_id}/archive/{growth_entry['entry_id']}#data"
        #             )
        #         for search_quantities in growth_entry["search_quantities"]:
        #             if (
        #                 search_quantities["path_archive"]
        #                 == "data.substrate_temperature"
        #             ):
        #                 self.substrate_temperature = search_quantities["float_value"]
        #             if search_quantities["path_archive"] == "data.oxygen_argon_ratio":
        #                 self.oxygen_argon_ratio = search_quantities["float_value"]
        #             if search_quantities["path_archive"] == "data.composition":
        #                 self.composition = search_quantities["str_value"][0]
        #     if not found_id:
        #         logger.warning(
        #             f"The lab_id '{self.growth_run_constant_parameters.lab_id}' was not found in any 'GrowthMbe1PDIConstantParameters' entry in Nomad. Check if it exist and try to reference it manually."
        #         )
        # else:
        #     logger.warning(
        #         "No lab_id for 'GrowthMbe1PDIConstantParameters' found. The archive couldn't be referenced."
        #     )

    # def normalize(self, archive, logger: BoundLogger) -> None:
    #     '''
    #     The normalizer for the `MbeBinaryOxidesPDIExperiment` class.
    #     '''
    #     super(MbeBinaryOxidesPDIExperiment, self).normalize(archive, logger)
    ## Potential weak code in next lines:
    ## I want to get back to GrowthRun entry (already created by tabular parser)
    ## and set the "reference" quantity in grwon_samples.
    ## Here two example codes by Theodore Chang, first touches the raw file, second touches the processed file.
    #### ONE
    ## 1. get the file name of archive/entry containing grown_sample_ref
    ## 2. overwrite yaml for this entry
    ## 3. reprocess
    # grown_sample_ref.reference = f'../uploads/{archive.m_context.upload_id}/archive/{hash(archive.m_context.upload_id, filename)}#data'
    # grown_sample_archive = grown_sample_ref
    # while not isinstance(grown_sample_archive, EntryArchive):
    #     grown_sample_archive=grown_sample_archive.m_parent
    # grown_sample_file_name:str = grown_sample_archive.metadata.mainfile
    # create_archive(
    #     grown_sample_archive.m_to_dict(), archive.m_context, grown_sample_file_name, filetype, logger,bypass_check=True)
    #### TWO
    ## alternatively directly overwite the processed msg file
    # grown_sample_upload_id:str = grown_sample_archive.metadata.upload_id
    # grown_sample_entry_id:str = grown_sample_archive.metadata.entry_id
    # StagingUploadFiles(grown_sample_upload_id).write_archive(grown_sample_entry_id, grown_sample_archive.m_to_dict())


m_package.__init_metainfo__()
